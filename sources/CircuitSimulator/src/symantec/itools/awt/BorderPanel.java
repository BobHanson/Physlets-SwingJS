package symantec.itools.awt;

//import a2s.*;
import java.awt.*;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.LayoutManager;

import java.beans.PropertyVetoException;
import java.beans.PropertyChangeListener;
import java.beans.VetoableChangeListener;
import java.beans.PropertyChangeEvent;
import symantec.itools.awt.util.ColorUtils;
import java.awt.event.ContainerListener;
import java.awt.event.ContainerEvent;
import java.util.Vector;

import javax.swing.JComponent;

import java.util.ResourceBundle;


//	01/29/97	TWB	Integrated changes from Macintosh
//  05/31/97	RKM	Updated to support Java 1.1
//					Made properties bound & constrained
//  07/19/97	LAB	Reorganized code to follow the GoodBeanSpec.  Updated deprecated
//					preferredSize and minimumSize calls. Made default protection
//					methods protected. Updated version to 1.1.
//  07/20/97	RKM	Changed to new addImpl override, removed the five add variant overrides
//  07/23/97	LAB	Constrained the BevelStyle property to only known styles.  Changed
//					setBorderColor(Color clr, boolean useForLabel) to throw a PropertyVetoException
//					as it should.  Updated to calculate the bevel raised and bevel lowered colors
//					from the background color.  Updated calls to reshape to setBounds.  Deprecated
//					reshape in favor of setBounds.
//  07/25/97    CAR marked fields transient as needed
//                  innerclasses implement java.io.Serialize
//                  added back in null layout check in setLayout, without this check the bean throws an NullPointer
//                  exception at instantiation time
//  08/04/97	LAB	Now uses ColorUtils.calculateHilightColor and ColorUtils.calculateShadowColor
//					to calculate the bevel colors more intelligently.
//	08/15/97	LAB	Reworked the way colors were calculated to avoid NullPointerExceptions,
//					and potential redraw problems.  Now colors are recalculated in paint,
//					if needed.
//  08/29/97    CAR modified getPreferredSize and getMinimumSize
//  09/01/97    CAR calls to add/removeContainerListener use the inner panel (which is considered the main container)
//                  container events must appear to be generated by the outermost panel
//	09/11/97	LAB	Added repaint call to setPaddingLeft, Right, Top, and Bottom, and added
//					a fillRect to draw() to fix some drawing artifacts (Addresses Mac Bug #7617).
//					Changed names of strings in PropertyChangeEvent handling to follow Bean Spec
//					naming conventions.
//  10/20/97    CAR moved error messages into ResourceBundle

/**
 * BorderPanel is a panel component that has an optional border
 * and optional text title.
 * @version 1.1, July 19, 1997
 * @author Symantec
 */
public class BorderPanel extends Panel implements AlignStyle, BevelStyle, ContainerListener
{
    /**
     * Constructs a new default BorderPanel.
     * Its label will be ALIGN_CENTERED and it will have a BEVEL_LINE style border.
     */
	public BorderPanel()
	{
	    this(null, ALIGN_CENTERED, BEVEL_LINE);
	}

    /**
     * Constructs a new BorderPanel with the specified beveled border style.
     * It will have the ALIGN_CENTERED label alignment style.
     * @param style the desired beveled border style
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
     */
	public BorderPanel(int style)
	{
	    this(null, ALIGN_CENTERED, style);
	}

    /**
     * Constructs a new BorderPanel with the specified border label.
     * Its label will be ALIGN_CENTERED and it will have a BEVEL_LINE style border.
     * @param s the label for the panel's border
     */
	public BorderPanel(String s)
	{
	    this(s, ALIGN_CENTERED, BEVEL_LINE);
	}

    /**
     * Constructs a new BorderPanel with the specified border label
     * and given alignment.
     * @param s the label for the panel's border
     * @param alignment the label alignment
     * @see AlignStyle#ALIGN_LEFT
     * @see AlignStyle#ALIGN_CENTERED
     * @see AlignStyle#ALIGN_RIGHT
     */
	public BorderPanel(String s, int alignment)
	{
	    this(s, alignment, BEVEL_LINE);
	}

    /**
     * Constructs a new BorderPanel with the specified border label
     * and given alignment and border styles.
     * @param s the label for the panel's border
     * @param alignment the label alignment
     * @param style the border bevel style
     * @see AlignStyle#ALIGN_LEFT
     * @see AlignStyle#ALIGN_CENTERED
     * @see AlignStyle#ALIGN_RIGHT
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
     */
	public BorderPanel(String s, int alignment, int style)
	{
	    borderColor	= Color.black;
	    labelColor  = Color.black;
	    padleft     = 6;
	    padright    = 6;
	    padtop      = 10;
	    padbottom   = 6;
	    ixPad       = 4;
	    iyPadTop    = 2;
	    iyPadBottom = 7;

	    cachedBackground = getBackground();

	    label = (s != null && s.length() == 0) ? null : s;
	    labelAlignment = alignment;
	    internalInsets = new Insets(10, 10, 10, 10);
	    this.style     = style;
	    super.setLayout(null);
	    /**
	     * @j2sNative   this.setOpaque$Z(false);
	     */
	    panel = new Panel();
	    
	    /**
	     * @j2sNative   this.panel.setOpaque$Z(false);
	     */

	    super.add(panel);
	    if (panel != null)
	        panel.setLayout(null);
	    sizepanel(true);
        cListeners = new Vector();
	}

    /**
     * Sets the top border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @param newPadTop the top border outside padding amount, in pixels
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getPaddingTop
     */
	public void setPaddingTop(int newPadTop) throws PropertyVetoException
	{
	    if (padtop != newPadTop)
	    {
			Integer oldPadTopInt = new Integer(padtop);
			Integer newPadTopInt = new Integer(newPadTop);

			getVetos().fireVetoableChange("paddingTop", oldPadTopInt, newPadTopInt);

		    padtop = newPadTop;
		    sizepanel(true);
		    invalidate();
   			repaint();

			getChanges().firePropertyChange("paddingTop", oldPadTopInt, newPadTopInt);
	    }
	}
	
	private symantec.itools.beans.PropertyChangeSupport getChanges() {
		return (changes == null ? (changes = new symantec.itools.beans.PropertyChangeSupport(this)) : changes);
	}

	private symantec.itools.beans.VetoableChangeSupport getVetos() {
		return (vetos == null ? (vetos = new symantec.itools.beans.VetoableChangeSupport(this)) : vetos);
	}

    /**
     * Gets the current top border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @return the top border outside padding amount, in pixels
     * @see #setPaddingTop
     */
	public int getPaddingTop()
	{
	    return padtop;
	}

    /**
     * Sets the bottom border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @param newPadBottom the bottom border outside padding amount, in pixels
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getPaddingBottom
     */
	public void setPaddingBottom(int newPadBottom) throws PropertyVetoException
	{
	    if (padbottom != newPadBottom)
	    {
			Integer oldPadBottomInt = new Integer(padbottom);
			Integer newPadBottomInt = new Integer(newPadBottom);

			getVetos().fireVetoableChange("paddingBottom", oldPadBottomInt, newPadBottomInt);

		    padbottom = newPadBottom;
		    sizepanel(true);
		    invalidate();
			repaint();

			getChanges().firePropertyChange("paddingBottom", oldPadBottomInt, newPadBottomInt);
	    }
	}

    /**
     * Gets the current bottom border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @return the bottom border outside padding amount, in pixels
     * @see #setPaddingBottom
     */
	public int getPaddingBottom()
	{
	    return padbottom;
	}

    /**
     * Sets the left border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @param newPadLeft the left border outside padding amount, in pixels
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getPaddingLeft
     */
	public void setPaddingLeft(int newPadLeft) throws PropertyVetoException
	{
	    if (padleft != newPadLeft)
	    {
			Integer oldPadLeftInt = new Integer(padleft);
			Integer newPadLeftInt = new Integer(newPadLeft);

			getVetos().fireVetoableChange("paddingLeft", oldPadLeftInt, newPadLeftInt);

			padleft = newPadLeft;
			sizepanel(true);
			invalidate();
			repaint();

			getChanges().firePropertyChange("paddingLeft", oldPadLeftInt, newPadLeftInt);
	    }
	}

    /**
     * Gets the current left border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @return the left border outside padding amount, in pixels
     * @see #setPaddingLeft
     */
	public int getPaddingLeft()
	{
	    return padleft;
	}

    /**
     * Sets the right border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @param newPadRight the right border outside padding amount, in pixels
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getPaddingRight
     */
	public void setPaddingRight(int newPadRight) throws PropertyVetoException
	{
	    if (padright != newPadRight)
	    {
			Integer oldPadRightInt = new Integer(padright);
			Integer newPadRightInt = new Integer(newPadRight);

			getVetos().fireVetoableChange("paddingRight", oldPadRightInt, newPadRightInt);

		    padright = newPadRight;
			sizepanel(true);
			invalidate();
			repaint();

			getChanges().firePropertyChange("paddingRight", oldPadRightInt, newPadRightInt);
	    }
	}

    /**
     * Gets the current right border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     * @return the right border outside padding amount, in pixels
     * @see #setPaddingRight
     */
	public int getPaddingRight()
	{
	    return padright;
	}

    /**
     * Sets the top border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @param t top border inset padding amount
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getIPadTop
     * @see #panel
     */
	public void setIPadTop(int t) throws PropertyVetoException
	{
		if (iyPadTop != t)
		{
			Integer oldPadTopInt = new Integer(iyPadTop);
			Integer newPadTopInt = new Integer(t);

			getVetos().fireVetoableChange("iPadTop", oldPadTopInt, newPadTopInt);

		    iyPadTop = t;

		    getChanges().firePropertyChange("iPadTop", oldPadTopInt, newPadTopInt);

		    sizepanel(true);
		    invalidate();
		}
	}

    /**
     * Gets the current top border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @return top border inset padding amount
     * @see #setIPadTop
     * @see #panel
     */
	public int getIPadTop()
	{
	    return iyPadTop;
	}

    /**
     * Sets the bottom border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @param b bottom border inset padding amount
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getIPadBottom
     * @see #panel
     */
	public void setIPadBottom(int b) throws PropertyVetoException
	{
		if (iyPadBottom != b)
		{
			Integer oldPadBottomInt = new Integer(iyPadBottom);
			Integer newPadBottomInt = new Integer(b);

			getVetos().fireVetoableChange("iPadBottom", oldPadBottomInt, newPadBottomInt);

		    iyPadBottom = b;

		    getChanges().firePropertyChange("iPadBottom", oldPadBottomInt, newPadBottomInt);

		    sizepanel(true);
		    invalidate();
		}
	}

    /**
     * Gets the current bottom border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @return bottom border inset padding amount
     * @see #setIPadBottom
     * @see #panel
     */
	public int getIPadBottom()
	{
	    return iyPadBottom;
	}

    /**
     * Sets the side border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @param s side border inset padding amount
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getIPadSides
     * @see #panel
     */
	public void setIPadSides(int s) throws PropertyVetoException
	{
		if (ixPad != s)
		{
			Integer oldIPadSidesInt = new Integer(ixPad);
			Integer newIPadSidesInt = new Integer(s);

			getVetos().fireVetoableChange("iPadSides", oldIPadSidesInt, newIPadSidesInt);

		    ixPad = s;

		    getChanges().firePropertyChange("iPadSides", oldIPadSidesInt, newIPadSidesInt);

		    sizepanel(true);
		    invalidate();
		}
	}

    /**
     * Gets the current side border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @return side border inset padding amount
     * @see #setIPadSides
     * @see #panel
     */
	public int getIPadSides()
	{
	    return ixPad;
	}

    /**
     * Sets the text label to display in the border.
     * @param newLabel the new border label.  If null, label is removed
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getLabel
     */
	public void setLabel(String newLabel) throws PropertyVetoException
	{
		//Preprocess s, since null is what instead of an empty string
		if (newLabel != null && newLabel.length() == 0)
			newLabel = null;

		if (!symantec.itools.util.GeneralUtils.objectsEqual(label,newLabel))
		{
			String oldLabel = label;

			getVetos().fireVetoableChange("label", oldLabel, newLabel);

		    label = newLabel;

		    getChanges().firePropertyChange("label", oldLabel, newLabel);

		    sizepanel(true);
		    //invalidate();
		    repaint();
		}
	}

    /**
     * Returns the text label displayed in the border.
     * @see #setLabel
     */
	public String getLabel()
	{
	    return label;
	}

	/**
	 * Sets the current border color.
	 * @param newBorderColor the new border color
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
	 * @see #getBorderColor
	 */
	public void setBorderColor(Color newBorderColor) throws PropertyVetoException
	{
		if (!symantec.itools.util.GeneralUtils.objectsEqual(borderColor,newBorderColor))
		{
			Color oldBorderColor = borderColor;

			getVetos().fireVetoableChange("borderColor",oldBorderColor,newBorderColor);

			borderColor			= newBorderColor;

			getChanges().firePropertyChange("borderColor",oldBorderColor,newBorderColor);

			repaint();
		}
	}

    /**
     * Gets the current border color.
     * @return the current border color
     * @see #setBorderColor
     */
	public Color getBorderColor()
	{
	    return borderColor;
	}

	/**
	 * Sets the border label color.
	 * @param newLabelBorderColor new border label color
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
	 * @see #getLabelColor
	 */
	public void setLabelColor(Color newLabelBorderColor) throws PropertyVetoException
	{
		if (!symantec.itools.util.GeneralUtils.objectsEqual(labelColor,newLabelBorderColor))
		{
			Color oldLabelColor = labelColor;

			getVetos().fireVetoableChange("labelColor",oldLabelColor,newLabelBorderColor);

		    labelColor = newLabelBorderColor;

			getChanges().firePropertyChange("labelColor",oldLabelColor,newLabelBorderColor);

			repaint();
		}
	}

	/**
	 * Gets the current border label color.
	 * @return current border label color
	 */
	public Color getLabelColor()
	{
	    return labelColor;
	}

    /**
     * Sets the border label alignment.
     * @param alignment the new border label alignment.
     * One of ALIGN_LEFT, ALIGN_CENTERED, or ALIGN_RIGHT
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getAlignStyle
     * @see AlignStyle#ALIGN_LEFT
     * @see AlignStyle#ALIGN_CENTERED
     * @see AlignStyle#ALIGN_RIGHT
     */
	public void setAlignStyle(int newLabelAlignment) throws PropertyVetoException
	{
		if (labelAlignment != newLabelAlignment)
		{
			Integer oldLabelAlignmentInteger = new Integer(labelAlignment);
			Integer newLabelAlignmentInteger = new Integer(newLabelAlignment);

			getVetos().fireVetoableChange("alignStyle",oldLabelAlignmentInteger,newLabelAlignmentInteger);

		    labelAlignment = newLabelAlignment;

			getChanges().firePropertyChange("alignStyle",oldLabelAlignmentInteger,newLabelAlignmentInteger);

		    sizepanel(true);
		    //invalidate();
		    repaint();
		}
	}

    /**
     * Gets the current border label alignment.
     * @return the current border label alignment.
     * One of ALIGN_LEFT, ALIGN_CENTERED, or ALIGN_RIGHT
     * @see AlignStyle#ALIGN_LEFT
     * @see AlignStyle#ALIGN_CENTERED
     * @see AlignStyle#ALIGN_RIGHT
     * @see #setAlignStyle
     */
	public int getAlignStyle()
	{
	    return labelAlignment;
	}

    /**
     * Sets the border style.
     * @param s the new border style.
     * One of BEVEL_RAISED, BEVEL_LOWERED, BEVEL_LINE, or BEVEL_NONE
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
     * @see #getBevelStyle
     */
	public void setBevelStyle(int newBevelStyle) throws PropertyVetoException
	{
		if (style != newBevelStyle)
		{
			Integer oldBevelStyleInteger = new Integer(style);
			Integer newBevelStyleInteger = new Integer(newBevelStyle);

			getVetos().fireVetoableChange("bevelStyle",oldBevelStyleInteger,newBevelStyleInteger);

		    style = newBevelStyle;

			getChanges().firePropertyChange("bevelStyle",oldBevelStyleInteger,newBevelStyleInteger);

		    repaint();
		}
	}

    /**
     * Gets the current border style.
     * @return current border style.
     * One of BEVEL_RAISED, BEVEL_LOWERED, BEVEL_LINE, or BEVEL_NONE
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
     * @see #setBevelStyle
     */
	public int getBevelStyle()
	{
	    return style;
	}

	//???RKM??? Need JavaDoc here BUG: Was dup of getInternalInsets
    /**
     * Sets the internal border insets.
     * The left and right fields of the internal insets are used while
     * determining the preferred width of this component.
     * @param newInsets the new internal border insets
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #getInternalInsets
     */
	public void setInternalInsets(Insets newInsets) throws PropertyVetoException
	{
		if (!symantec.itools.util.GeneralUtils.objectsEqual(internalInsets,newInsets))
		{
			Insets oldInsets = internalInsets;

			getVetos().fireVetoableChange("internalInsets",oldInsets,newInsets);

		    internalInsets = newInsets;

			getChanges().firePropertyChange("internalInsets",oldInsets,newInsets);

		    sizepanel(true);
		    invalidate();
		}
	}

    /**
     * Gets the current internal border insets.
     * The left and right fields of the internal insets are used while
     * determining the preferred width of this component.
     * @return the current internal border insets
     * @see #setInternalInsets
     */
	public Insets getInternalInsets()
	{
	    return internalInsets;
	}

    /**
     * Sets the border padding amounts.
     * This are the distances between the drawn border and the actual
     * bounds of the component.
     * @param t the top padding amount
     * @param b the bottom padding amount
     * @param l the left padding amount
     * @param r the right padding amount
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     */
	public void setPadding(int t, int b, int l, int r) throws PropertyVetoException
	{
		setPaddingTop(t);
		setPaddingBottom(b);
		setPaddingLeft(l);
		setPaddingRight(r);
	}

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by setBorderColor & setLabelColor.
     * @exception PropertyVetoException
     * if the specified property value is unacceptable
     * @see #setBorderColor(java.awt.Color)
     * @see #setLabelColor(java.awt.Color)
	 */
	public void setBorderColor(Color clr, boolean useForLabel) throws PropertyVetoException
	{
		setBorderColor(clr);

	    if (useForLabel)
	    {
	    	setLabelColor(clr);
	    }
	}

	/**
	 * Returns the recommended dimensions to properly display this component.
     * This is a standard Java AWT method which gets called to determine
     * the recommended size of this component. The size returned is large
     * enough to display the entire border label and the panel within the
     * border.
     *
     * @see #minimumSize
	 */
	public Dimension getPreferredSize()
	{
    	Dimension p = size();
    	Dimension m = getMinimumSize();
    	return new Dimension(Math.max(p.width, m.width), Math.max(p.height, m.height));
	}

	/**
	 * @deprecated
     * @see #getPreferredSize
	 */
	public Dimension preferredSize()
	{
		return getPreferredSize();
	}

	/**
	 * Returns the minimum dimensions to properly display this component.
     * This is a standard Java AWT method which gets called to determine
     * the minimum size of this component.
     *
     * @see #getPreferredSize
	 */
	public Dimension getMinimumSize()
	{
	    return new Dimension(20, 40);
	}

	/**
	 * @deprecated
     * @see #getMinimumSize
	 */
	public Dimension minimumSize()
	{
		return getMinimumSize();
	}

	/**
	 * Sets the layout manager to be used to layout this container.
	 * This is a standard Java AWT method which gets called to specify
	 * which layout manager should be used to layout the components in
	 * standard containers.
	 *
	 * @param l the layout manager to use to layout this container's components
	 * @see #getLayout
	 **/
	public void setLayout(LayoutManager l)
	{
        if (panel != null)
        {
    		panel.setLayout(l);
		}
	}

	/**
	 * Gets the current border panel layout manager.
	 * @return current LayoutManager of border panel
	 * @see #setLayout
	 */
	public LayoutManager getLayout()
	{
	    return panel.getLayout();
	}

    /**
     * Gets the component at the specified zero-relative component index.
     * This is a standard Java AWT method which gets called to return
     * the component at a specific position.
     *
     * @param i the zero-relative index of the component to retrieve
     * @return the component at the given index
     * @exception java.lang.ArrayIndexOutOfBoundsException if the given
     * component index does not exist
     * @see #getComponents
     */
	public Component getComponent(int i)
	{
	    return panel.getComponent(i);
	}

	/**
	 * Returns all of the components in this container.
	 * This is a standard Java AWT method which gets called to return
	 * an array of all of the components in this container.
	 *
	 * @return an array of components in this container
     * @see #getComponent
     */
	public Component[] getComponents()
	{
	    return panel.getComponents();
	}

	/**
	 * Returns the number of components in this container.
	 *
	 * @return the number of components in this container
     * @see #getComponent
     */
	public int getComponentCount()
	{
	    return panel.getComponentCount();
	}

	/**
	 * Is the specified bevelStyle valid?
	 * @param bevelStyle the style to test
	 * @return if true then the parameter was equal to one of the following:
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
	 */
	public boolean isValidBevelStyle(int bevelStyle)
	{
		switch(bevelStyle)
		{
    		case BEVEL_RAISED:
    		case BEVEL_LOWERED:
    		case BEVEL_LINE:
    		case BEVEL_NONE:
				return true;
			default:
				return false;
		}
	}

	/**
	 * Tells this component that it has been added to a container.
	 * This is a standard Java AWT method which gets called by the AWT when
	 * this component is added to a container. Typically, it is used to
	 * create this component's peer.
	 *
	 * It has been overridden here to hook-up event listeners, and
	 * to resize self after peer created.
	 *
	 * @see #removeNotify
	 */
	public synchronized void addNotify()
	{
		super.addNotify();
        errors = ResourceBundle.getBundle("symantec.itools.resources.ErrorsBundle");

		sizepanel(true);

		//Hook up listeners
		if (veto == null)
		{
			veto = new Veto();
			addBevelStyleListener(veto);
		}

		if (panel != null)
		    panel.addContainerListener(this);
	}

	/**
	 * Tells this component that it is being removed from a container.
	 * This is a standard Java AWT method which gets called by the AWT when
	 * this component is removed from a container. Typically, it is used to
	 * destroy the peers of this component and all its subcomponents.
	 *
	 * It has been overridden here to unhook event listeners.
	 *
	 * @see #addNotify
	 */
	public synchronized void removeNotify()
	{
		//Unhook listeners
		if (veto != null)
		{
			removeBevelStyleListener(veto);
			veto = null;
		}

		if (panel != null)
		    panel.removeContainerListener(this);

		super.removeNotify();
	}

	/**
     * Handles the laying out of components within this component.
     * This is a standard Java AWT method which gets called by the AWT
     * when this component is validated with the validate() method.
     *
     * @see java.awt.Container#validate
	 */
	public void layout()
	{
	    sizepanel(false);
	    panel.layout();
	}

    /**
     * Adds the specified component to this container at the specified
     * index.  Also notifies the layout manager to add the component to
     * the this container's layout using the specified constraints object.
     * <p>
     * This is the method to override if you want to track every add
     * request to a container.  An overriding method should usually
     * include a call to super.addImpl(comp, constraints, index).
     *
     * BorderPanel overrides this method to send all additions to it to\
     * its internal panel
     *
     * @param comp the component to be added
     * @param constraints an object expressing layout contraints for this
     * component
     * @param index the position in the container's list at which to
     * insert the component.  -1 means insert at the end.
     * @see #remove
     * @see LayoutManager
     */
	protected void addImpl(Component comp, Object constraints, int index)
	{
	    if (comp == panel)
			super.addImpl(comp,constraints,index);
		else
			panel.add(comp,constraints,index);
	}

	/**
	 * Removes the component at the specified index from this container.
	 * @param index the index of the component to be removed
	 * @see java.awt.Container#add
	 */
	public void remove(int index)
	{
	    panel.remove(index);
	}

	public void remove(Component comp)
	{
	    panel.remove(comp);
	}

	/**
	 * Removes all the components from this container.
	 * This is a standard Java AWT method which gets called to remove all
	 * the components from a container. When this happens each component's
	 * removeNotify() will also get called to indicate component removal.
	 *
	 * @see #remove
	 * @see java.awt.Container#add
	 */
	public void removeAll()
	{
	    panel.removeAll();
	}

	/**
	 * Moves and/or resizes this component.
	 * This is a standard Java AWT method which gets called to move and/or
	 * resize this component. Components that are in containers with layout
	 * managers should not call this method, but rely on the layout manager
	 * instead.
	 *
	 * @param x horizontal position in the parent's coordinate space
	 * @param y vertical position in the parent's coordinate space
	 * @param width the new width
	 * @param height the new height
	 */
	public void setBounds(int x, int y, int width, int height)
	{
	    super.setBounds(x, y, width, height);
	    sizepanel(false);
	}

	/**
	 * @deprecated
	 * @see #setBounds
	 */
	public void reshape(int x, int y, int width, int height)
	{
		//Can not call setBounds here, or we would be in an endless loop because of the AWT.
	    super.reshape(x, y, width, height);
	    sizepanel(false);
	}

//    /**
//     * Handles redrawing of this component on the screen.
//     * This is a standard Java AWT method which gets called by the Java
//     * AWT (repaint()) to handle repainting this component on the screen.
//     * The graphics context clipping region is set to the bounding rectangle
//     * of this component and its [0,0] coordinate is this component's
//     * top-left corner.
//     * Typically this method paints the background color to clear the
//     * component's drawing space, sets graphics context to be the foreground
//     * color, and then calls paint() to draw the component.
//     *
//     * @param g the graphics context
//     * @see java.awt.Component#repaint
//     * @see #paint
//     */
//	public void update(Graphics g)
//	{
//	    Dimension s;
//	    Insets insets;
//
//	    s      = size();
//	    insets = insets();
//
//		//??? LAB ??? What is all this doing?  Doesn't seem to apply.
//	    g.setColor(getBackground());
//
//	    if (insets.left > 0)
//	    {
//	        g.fillRect(0, 0, insets.left, s.height);
//	    }
//
//	    if (insets.top > 0)
//	    {
//	        g.fillRect(0, 0, s.width, insets.top);
//	    }
//
//	    if (insets.bottom > 0)
//	    {
//	        g.fillRect(0, s.height-insets.bottom, s.width, insets.bottom);
//	    }
//
//	    if (insets.right > 0)
//	    {
//	        g.fillRect(s.width-insets.right, 0, insets.right, s.height);
//	    }
//
////	    paint(g);
//	    panel.repaint();
//	}

	/**
	 * Returns the number of components in this container.
	 * This is a standard Java AWT method which gets called to return a count
	 * of the components within this container.
	 *
	 */
	public int countComponents()
	{
	    return panel.countComponents();
	}

    /**
     * Returns the amount of space used by the current border.
     * This is a standard Java AWT method which gets called to determine
     * the size of the current border. The returned value is the width
     * of each border side in pixels.
     *
     * @return the current border insets
     */
	public Insets insets()
	{
	    int h = getLabelTopMargin();
	    Insets insets = getInternalInsets();

	    return new Insets(h + insets.top, insets.left, insets.bottom, insets.right);
	}

	/**
	 * Paints this component using the given graphics context.
     * This is a standard Java AWT method which typically gets called
     * by the AWT to handle painting this component. It paints this component
     * using the given graphics context. The graphics context clipping region
     * is set to the bounding rectangle of this component and its [0,0]
     * coordinate is this component's top-left corner.
     *
     * @param g the graphics context used for painting
     * @see java.awt.Component#repaint
     * @see #update
	 */
	public void paint(Graphics g)
	{
//	    super.paint(g);
	    sizepanel(false);
		Color curBackground = getBackground();
		if (!symantec.itools.util.GeneralUtils.objectsEqual(curBackground, cachedBackground))
		{
			cachedBackground = curBackground;
			calculateHilightColors(curBackground);
		}
	    g.setColor(curBackground);
	    draw(g);
	    // this is critical
	    super.paint(g);
	}

	/**
	 * Sets this component's background color.
	 * This is a standard Java AWT method which gets called to change
	 * the background color of this component.
	 *
	 * @param c the new background color
	 * @see java.awt.Component#getBackground
	 */
	public void setBackground(Color c)
	{
	    super.setBackground(c);
	    JComponent t;
	    //we have to do this, because these are just painting their backgrounds a bit
	    if (/** @j2sNative ! */false)
	    ((JComponent) (Object) this).setOpaque(false);
	    if(panel==null) return;
	    panel.setBackground(c);
	    if (/** @j2sNative ! */false)
	    ((JComponent) (Object) panel).setOpaque(false);
	}

    /**
     * A method of the ContainerListener interface.
     * This method is called when a component is added to this component's panel.
     * @param e the container event
     * @see java.awt.ContainerListener
     */
	public void componentAdded(ContainerEvent e) {
	    if (e.getSource() == panel) {
	        for (int i = 0; i < cListeners.size(); ++i) {
	            ((ContainerListener) cListeners.elementAt(i)).componentAdded(
	                new ContainerEvent(this, ContainerEvent.COMPONENT_ADDED, e.getChild()));
	        }
	    }
	}

    /**
     * A method of the ContainerListener interface.
     * This method is called when a component is removed from this component's panel.
     * @param e the container event
     * @see java.awt.ContainerListener
     */
	public void componentRemoved(ContainerEvent e) {
	    if (e.getSource() == panel) {
	        for (int i = 0; i < cListeners.size(); ++i) {
	            ((ContainerListener) cListeners.elementAt(i)).componentRemoved(
	                new ContainerEvent(this, ContainerEvent.COMPONENT_REMOVED, e.getChild()));
	        }
	    }
	}

	public synchronized void addContainerListener(ContainerListener l) {
	    if (panel != null) {
	        panel.addContainerListener(l);
	        cListeners.addElement(l);
	    }
	}

	public synchronized void removeContainerListener(ContainerListener l) {
	    if (panel != null) {
	        panel.removeContainerListener(l);
	        cListeners.removeElement(l);
	    }
	}

	/**
	 * Adds a listener for all event getChanges().
	 * @param listener the listener to add.
	 * @see #removePropertyChangeListener
	 */
	public synchronized void addPropertyChangeListener(PropertyChangeListener listener)
	{
		//super.addPropertyChangeListener(listener);
		getChanges().addPropertyChangeListener(listener);
	}

	/**
	 * Removes a listener for all event getChanges().
	 * @param listener the listener to remove.
	 * @see #addPropertyChangeListener
	 */
	public synchronized void removePropertyChangeListener(PropertyChangeListener listener)
	{
		//super.removePropertyChangeListener(listener);
		getChanges().removePropertyChangeListener(listener);
	}

	/**
	 * Adds a vetoable listener for all event getChanges().
	 * @param listener the listener to add.
	 * @see #removeVetoableChangeListener
	 */
	public synchronized void addVetoableChangeListener(VetoableChangeListener listener)
	{
		 //super.addVetoableChangeListener(listener);
		getVetos().addVetoableChangeListener(listener);
	}

	/**
	 * Removes a vetoable listener for all event getChanges().
	 * @param listener the listener to remove.
	 * @see #addVetoableChangeListener
	 */
	public synchronized void removeVetoableChangeListener(VetoableChangeListener listener)
	{
		//super.removeVetoableChangeListener(listener);
		getVetos().removeVetoableChangeListener(listener);
	}

    /**
     * Adds a listener for Orienation getChanges().
     * @param listener the listener to add.
     * @see #removeBevelStyleListener
     */
    public synchronized void addBevelStyleListener(PropertyChangeListener listener)
    {
    	getChanges().addPropertyChangeListener("bevelStyle", listener);
    }

    /**
     * Removes a listener for Orienation getChanges().
     * @param listener the listener to remove.
     * @see #addBevelStyleListener
     */
    public synchronized void removeBevelStyleListener(PropertyChangeListener listener)
    {
    	getChanges().removePropertyChangeListener("bevelStyle", listener);
    }

    /**
     * Adds a vetoable listener for BevelStyle getChanges().
     * @param listener the listener to add.
     * @see #removeBevelStyleListener
     */
    public synchronized void addBevelStyleListener(VetoableChangeListener listener)
    {
		getVetos().addVetoableChangeListener("bevelStyle", listener);
    }

    /**
     * Removes a vetoable listener for BevelStyle getChanges().
     * @param listener the listener to remove.
     * @see #addBevelStyleListener
     */
    public synchronized void removeBevelStyleListener(VetoableChangeListener listener)
    {
    	getVetos().removeVetoableChangeListener("bevelStyle", listener);
    }

	/**
	 * This is the PropertyChangeEvent handling inner class for the constrained BevelStyle property.
	 * Handles vetoing BevelStyles that are not valid.
	 */
	class Veto implements java.beans.VetoableChangeListener, java.io.Serializable
	{
	    /**
	     * This method gets called when an attempt to change the constrained BevelStyle property is made.
	     * Ensures the given Orientation is valid.
	     *
	     * @param     e a <code>PropertyChangeEvent</code> object describing the
	     *   	      event source and the property that has changed.
	     * @exception PropertyVetoException if the recipient wishes the property
	     *              change to be rolled back.
	     */
	    public void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException
	    {
	    	int i = ((Integer)e.getNewValue()).intValue();
	        if (!isValidBevelStyle(i))
	        {
	            throw new PropertyVetoException(errors.getString("InvalidBevelStyle") + i, e);
	        }
	    }
	}

    /**
     * Sizes the border panel from the padding, inset, and label margin information.
     * @param force force setBounds even if the overall size hasn't changed
     */
	protected void sizepanel(boolean force)
	{
	    Dimension s;

	    s = size();

	    if (force || oldSize.width != s.width || oldSize.height != s.height)
	    {
	        oldSize = s;
	        panel.setBounds(padleft + ixPad,
	              getLabelTopMargin() + iyPadTop,
	              s.width - padright - padleft - ixPad * 2 - 1,
	              s.height - padbottom - getLabelTopMargin() - iyPadBottom - iyPadTop - 1);
	    }
	}

	/**
	 * Draws the border panel.
	 * @param g current graphics object
	 */
	protected void draw(Graphics g)
	{
		Dimension s;
		int delta;
		FontMetrics fm;
		int x;
		int y;
		int w;
		int h;

		s = size();
		delta = padtop;
		fm = getFontMetrics(getFont());

		g.clipRect(0, 0, s.width, s.height);
		//Erase our background.
		g.fillRect(0, 0, s.width, s.height);

		if (label != null && fm != null)
		{
			delta = (fm.getAscent()  + fm.getDescent() + padtop) / 2;
		}

		x = padleft;
		y = delta;
		w = s.width - padleft - padright - 1;
		h = s.height - 1 - delta - padbottom;

		drawBorder(g, x, y, w, h);

		drawLabel(g, fm);
	}

    /**
     * Draws the border panel border.
     * @param g current graphics object
     * @param x x coordinate of panel object
     * @param y y coordinate of panel object
     * @param w w width of panel object
     * @param h h height of panel object
     */
	protected void drawBorder(Graphics g, int x, int y, int w, int h)
	{
	    switch(style)
	    {
	        case BEVEL_RAISED :
	        {
	            g.setColor(bevelLighterColor);
	            g.drawLine(x, y, x + w, y);
	            g.drawLine(x, y, x, y + h);
	            g.setColor(bevelDarkerColor);
	            g.drawLine(x, y + h, x + w, y + h);
	            g.drawLine(x + w, y, x + w, y + h);
	            break;
	        }
	        case BEVEL_LOWERED :
	        {
	            g.setColor(bevelDarkerColor);
	            g.drawLine(x, y, x + w, y);
	            g.drawLine(x, y, x, y + h);
	            g.setColor(bevelLighterColor);
	            g.drawLine(x, y + h, x + w, y + h);
	            g.drawLine(x + w, y, x + w, y + h);
	            break;
	        }
	        case BEVEL_NONE :
	        {
	            break;
	        }
	        case BEVEL_LINE :
	        {
	            g.setColor(borderColor);
	            g.drawRect(x, y, w, h);
	            break;
	        }
	        default:
	        {
	            g.setColor(borderColor);
	            g.drawRect(x, y, w, h);
	            break;
	        }
	    }
	}

	/**
	 * Draws the border panel label.
	 * @param g current graphics object
	 * @param fm FontMetrics of border panel label
	 */
	protected void drawLabel(Graphics g, FontMetrics fm)
	{
	    if (label != null && (fm != null))
	    {
	        int fWidth;
	        Dimension s;
	        int stringWidth;
	        int ascent;
	        int descent;
	        int x;
	        int y;
	        int h;

	        fWidth = 10;
	        s = size();

	        if (getFont().getSize() > fWidth)
	        {
	            fWidth = fWidth + getFont().getSize() / 2;
	        }

	        stringWidth = fm.stringWidth(label);
	        ascent      = fm.getAscent();
	        descent     = fm.getDescent();

	        switch(labelAlignment)
	        {
	            case Label.CENTER:
	            {
	                x = padleft + (s.width - padleft - padright - stringWidth) / 2;
	                break;
	            }
	            case Label.RIGHT:
	            {
	                x = s.width - fWidth - (stringWidth + (labelpadx + labelipadx) / 2) - padright;
	                break;
	            }
	            case Label.LEFT:
	            {
	            }
	            default:
	            {
	                x = fWidth + (labelpadx + labelipadx) / 2 + padleft;
	            }
	        }

	        //y = ascent + padtop;			//This line is useless. 12/17/96 Levi Brown
	        h = ascent + descent+padtop;

	        y = (fWidth - h) / 2 + (padtop + ascent);
	        //h = fWidth;					//I like h better before... 12/17/96 Levi Brown

	        g.setColor(getBackground());
	        //Commented out the line below, to add my own below it.  12/17/96 Levi Brown
	        //g.fillRect(x - labelipadx / 2, 0, stringWidth + labelipadx, h);
	        g.fillRect(x - labelipadx / 2, y - 1 - ascent - padtop/2, stringWidth + labelipadx, h);
	        g.setColor(labelColor);
	        g.drawString(label, x, y - 1);
	    }
	}

    /**
     * Returns the current margin above the label.
     */
	protected int getLabelTopMargin()
	{
	    int  top;
	    Font font;

	    if (label == null)
	    {
	        return padtop;
	    }

	    top  = padtop;
	    font = getFont();

	    if (font != null)
	    {
	        FontMetrics fm;

	        fm  = getFontMetrics(font);
	        top = fm.getAscent() + fm.getDescent() + padtop + 0;
	    }

	    return top;
	}

	/**
	 * Returns the current label width margin.
	 */
	protected int getLabelWidthMargin()
	{
	    if (label == null)
	    {
	        return 0;
	    }

	    int w;
	    Font font;

	    w = 2 + internalInsets.left + internalInsets.right;
	    font = getFont();

	    if (font != null)
	    {
	        FontMetrics fm;

	        fm = getFontMetrics(font);
	        w  = Math.max(w, 2 + fm.stringWidth(label) + labelpadx + labelipadx);
	    }

	    return w;
	}

	/**
	 * Used to calculate the hilight colors from the background color.
	 * @see #paint
	 */
	protected void calculateHilightColors(Color c)
	{
		bevelLighterColor	= ColorUtils.calculateHilightColor(c);
		bevelDarkerColor	= ColorUtils.calculateShadowColor(c);
	}

    /**
     * The overall size before sizepanel().
     */
    Dimension oldSize = new Dimension();

    /**
     * Label horizontal coordinate padding constant, in pixels.
     */
    protected static final int labelpadx = 10;
    /**
     * Label horizontal coordinate inset constant, in pixels.
     */
    protected static final int labelipadx = 4;

    /**
     * Cached value of the background color.  Used to determine if calculated colors need to be updated.
     */
	protected Color cachedBackground	= null;
    /**
     * The border color.
     */
    protected Color borderColor;
    /**
     * The color to use as a hilight when BevelStyle is BEVEL_RAISED or BEVEL_LOWERED.
     */
    protected Color bevelLighterColor;
    /**
     * The color to use as a hilight when BevelStyle is BEVEL_RAISED or BEVEL_LOWERED.
     */
    protected Color bevelDarkerColor;
    /**
     * The border label color.
     */
    protected Color labelColor;
    /**
     * The top border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     */
    protected int padtop;
    /**
     * The bottom border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     */
    protected int padbottom;
    /**
     * The left border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     */
    protected int padleft;
    /**
     * The right border outside padding amount, in pixels.
     * This is the distance between the drawn border and the actual
     * bounds of the component.
     */
    protected int padright;
	/**
     * The side border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @see #panel
     */
	protected int ixPad;
    /**
     * The top border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @see #panel
     */
    protected int iyPadTop;
    /**
     * The bottom border inset padding amount, in pixels.
     * This is the distance between the drawn border and the usable
     * area within the border. It is used to determine the size of the
     * panel contained within this component's borders.
     * @see #panel
     */
    protected int iyPadBottom;
    /**
     * The border style: BEVEL_RAISED, BEVEL_LOWERED, BEVEL_LINE, or BEVEL_NONE.
     * @see BevelStyle#BEVEL_RAISED
     * @see BevelStyle#BEVEL_LOWERED
     * @see BevelStyle#BEVEL_LINE
     * @see BevelStyle#BEVEL_NONE
     */
    protected int style;
    /**
     * The text label to display in the border.
     */
    protected String label;
    /**
     * The border label alignment: ALIGN_LEFT, ALIGN_CENTERED, or ALIGN_RIGHT.
     * @see AlignStyle#ALIGN_LEFT
     * @see AlignStyle#ALIGN_CENTERED
     * @see AlignStyle#ALIGN_RIGHT
     */
    protected int labelAlignment;
    /**
     * The internal border insets.
     * The left and right fields are used while determining the preferred
     * width of this component.
     */
    protected Insets internalInsets;
    /**
     * The panel within the border. This is the panel that contains the
     * components added to the BorderPanel.
     */
    protected Panel panel;
    /**
     * Error strings.
     */
    transient protected ResourceBundle errors;

	private Vector cListeners = null;
	private Veto veto = null;
	private symantec.itools.beans.VetoableChangeSupport vetos;
	private symantec.itools.beans.PropertyChangeSupport changes;
}
