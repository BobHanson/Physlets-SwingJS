/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//***************************************************************

JEP - Java Expression Parser
    JEP is a Java package for parsing and evaluating mathematical
	expressions. It currently supports user defined variables,
	constant, and functions. A number of common mathematical
	functions and constants are included.

Author: Nathan Funk
Copyright (C) 2001 Nathan Funk

    JEP is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    JEP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with JEP; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


This file contains the grammar from which the parser is
generated. The parser generation tools being used are JavaCC
and its component JJTree. JJTree processes the .jjt file and
generates the .jj file. This file is then used be JavaCC to
generate the final java classes.

Knowledge of parser generation is definetly beneficial if you
are planning to make changes to this file. Although many parts
are self explanitory, it is helpful to know how the grammar is
handled by JJTree and JavaCC.

You can follow the structure of the grammar by starting in the
line which reads "ASTStart Start() #Start : {}". From there you
will be able to trace the same path the parser follows when
parsing an expression.

The concept of precedence is very important. Since this is a
recursive descent parser, it is easy to see which operators have
higher order of precedence. The following table outlines the
order incorporated in this grammar.

Order of precedence (from highest to lowest):
   ^
   %
   /
   *
   +,-
   <, >, <=, >=
   ==, !=
   !
   ||, &&


***************************************************************/



/***************************************************************
OPTIONS
***************************************************************/
options {                                                           
  STATIC=false;
}


/***************************************************************
PARSER BEGIN
***************************************************************/

PARSER_BEGIN(Parser)
package org.nfunk.jep;

import org.nfunk.jep.function.*;

class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/

  static SymbolTable symTab;
  static FunctionTable funTab;

  public static void main(String args[]) {

    System.out.println("Reading from standard input...");
    Parser t = new Parser(System.in);

    try {
      ASTStart n = t.Start();
      ParserVisitor v = new ParserDumpVisitor();
      n.jjtAccept(v, null);
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

	public Node parseStream(java.io.Reader stream, SymbolTable symTab_in, FunctionTable funTab_in, boolean traverse) throws ParseException
	{
		Parser t = new Parser(stream);
		symTab = symTab_in;
		funTab = funTab_in;

		ASTStart n = t.Start();

		if (traverse)
		{
			ParserVisitor v = new ParserDumpVisitor();
			n.jjtAccept(v, null);
			System.out.println("Thank you.");
		}

		return n.jjtGetChild(0);
	}


	private double parseIntToDouble(String buf)
	{
		double number = 0;
		int iLook = 0;

		for (iLook = 0; iLook < buf.length(); iLook++)
			number = 10*number + Character.digit(buf.charAt(iLook),10);

		return number;
	}
}

PARSER_END(Parser)


/***************************************************************
SKIP
***************************************************************/

SKIP :
{
  " "
//| "\t"
//| "\n"
//| "\r"
//| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
//| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
  	"\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
	"\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}


/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    Expression() <EOF>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { return jjtn000; }
  |  <EOF>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { throw new ParseException(token, "No expression entered"); return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



void Expression() : {}
{
	LogicalExpression()
}



void LogicalExpression() :
{
}
{
	NotExpression()
	(/*@bgen(jjtree) #FunNode( 2) */
          {
            ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/
	  ( "&&" NotExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
	    {
			jjtn001.setFunction(new Logical(0));
	    }
	  )/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/
	|/*@bgen(jjtree) #FunNode( 2) */
          {
            ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/
	  ( "||" NotExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
	    {
	    	jjtn002.setFunction(new Logical(1));
	    }
	  )/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/
	)*
}



void NotExpression() :
{}
{
  RelationalExpression()
  |/*@bgen(jjtree) #FunNode( 1) */
  {
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  ( "!" RelationalExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
    }
/*@egen*/
    {
	  jjtn001.setFunction(new Not());
    }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
    }
  }
/*@egen*/
}



void RelationalExpression() : {}
{
  OrEqualExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "<" OrEqualExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
	    jjtn001.setFunction(new Comparative(0));
      }
	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
	|/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    ( ">" OrEqualExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
        jjtn002.setFunction(new Comparative(1));
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
    }
/*@egen*/
  )*
}



void OrEqualExpression() : {}
{
  EqualExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "<=" EqualExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
	    jjtn001.setFunction(new Comparative(2));
      }
	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
	|/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    ( ">=" EqualExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
        jjtn002.setFunction(new Comparative(3));
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
    }
/*@egen*/
  )*
}



void EqualExpression() :
{
}
{
	AdditiveExpression()
	(/*@bgen(jjtree) #FunNode( 2) */
          {
            ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/
	  ( "!=" AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
	    {
	    jjtn001.setFunction(new Comparative(4));
	    }
	  )/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/
	|/*@bgen(jjtree) #FunNode( 2) */
          {
            ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/
	  ( "==" AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
	    {
	      jjtn002.setFunction(new Comparative(5));
	    }
	  )/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/
	)*
}



void AdditiveExpression() : {}
{
  MultiplicativeExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "+" MultiplicativeExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
        jjtn001.setFunction(new Add());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
    |/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    ( "-" MultiplicativeExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
        jjtn002.setFunction(new Subtract());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
    }
/*@egen*/
  )*
}




void MultiplicativeExpression() : {}
{
  DivisionExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "*" DivisionExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
        jjtn001.setFunction(new Multiply());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
  )*
}



void DivisionExpression() :
{
}
{
  ModulusExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "/" ModulusExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
        jjtn001.setFunction(new Divide());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
  )*
}



void ModulusExpression() :
{
}
{
  PowerExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "%" PowerExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
        jjtn001.setFunction(new Modulus());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
  )*
}



void PowerExpression() : {}
{
  UnaryExpression()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( "^" UnaryExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/
      {
        jjtn001.setFunction(new Power());
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
  )*
}



void UnaryExpression() :
{}
{
  ( "+" UnaryExpression())
|/*@bgen(jjtree) #FunNode( 1) */
  {
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  ( "-" UnaryExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
    }
/*@egen*/
    {
	  jjtn001.setFunction(new UMinus());
    }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
    }
  }
/*@egen*/
|
  UnaryExpressionNotPlusMinus()
}



void UnaryExpressionNotPlusMinus() :
{
  int reqArguments=1;
  boolean isSymbol = false;
  boolean isFunction = false;
  String identString = "";
}
{
  AnyConstant()
|
  "(" Expression() ")"
|
  ( LOOKAHEAD(2)/*@bgen(jjtree) FunNode */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (identString = Identifier()
      {
        if (funTab.containsKey(identString))
        {
          //Set number of required arguments
          reqArguments = ((PostfixMathCommand)funTab.get(identString)).getNumberOfParameters();
          jjtn001.setFunction((PostfixMathCommandI)funTab.get(identString));
        }
        else
        {
          throw new ParseException(token, "Unrecognized function \"" + identString + "\"");
        }
      }
      ArgumentList(reqArguments)/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001, true);
        jjtc001 = false;
      }
/*@egen*/
      {

      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/
    |/*@bgen(jjtree) VarNode */
    {
      ASTVarNode jjtn002 = new ASTVarNode(JJTVARNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    (identString = Identifier()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002, true);
        jjtc002 = false;
      }
/*@egen*/
      {
        if (symTab.containsKey(identString))
        {
          jjtn002.setName(identString);
		  jjtn002.setSymbolTable(symTab);
        }
        else
        {
          throw new ParseException(token, "Unrecognized symbol \"" + identString +"\"");
        }
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/
  )
}



void ArgumentList(int reqArguments) :
{
  int count = 0;
}
{
  "("
	[ Expression() {count = 1;} ]
  ( "," Expression() {count++;} )*
    {
      if (reqArguments != count)
      {
        throw new ParseException(token, "Expecting " + reqArguments + " parameter(s)");
      }
    }
  ")"
}


String Identifier() :
{
  Token t;
}
{
  t=<IDENTIFIER>
  {
    return t.image;
  }
}


void AnyConstant()          :
{/*@bgen(jjtree) Constant */
        ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	double value;
}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	t=<STRING_LITERAL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		String temp = (t.image).substring(1,t.image.length()-1);
		
		jjtn000.setValue(temp);
	}
	|
	value = RealConstant()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(new Double(value));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


double RealConstant() :
{
  Token t;
  double value;
}
{
  t=<INTEGER_LITERAL>
  {
  	try
  	{
	  value = parseIntToDouble(t.image);
  	} catch (Exception e)
  	{
      throw new ParseException(token, "Can't parse \"" + t.image + "\"");
  	}
	
	return value;
  }
  |
  t=<FLOATING_POINT_LITERAL>
  {
  	try
  	{
	  Double number = new Double(t.image);
	  value = number.doubleValue();
  	} catch (Exception e)
  	{
	  throw new ParseException(token, "Can't parse \"" + t.image + "\"");
  	}
	
	return value;

/*	//	Origional code for parsing a floating point number
    //  Replaced by Double constructor
  	String buf = t.image;
	double number;
	int iLook = 0;
  	int startPos = 0; //set starting position of number
  	int pointPos = 0;
  	boolean pointFound=false;

	while ((iLook < buf.length()) &&
		((Character.isDigit(buf.charAt(iLook))) || (buf.charAt(iLook)=='.')))
	{//go through numbers and only accept one '.'
		if (buf.charAt(iLook)=='.')
		{
			if (!pointFound)
			{// swallow one point
				pointFound = true;
				pointPos = iLook;
			}
			else
			{// point already found - now found again so stop
				break;
			}
		}
		++iLook;
	}

	if (pointFound)
	{// double number
		double n1, n2;
		if (pointPos-startPos > 0)
		{//pre . does exsist
			char chars1[] = new char[pointPos-startPos]; //up to '.'
			buf.getChars(startPos, pointPos, chars1, 0);
			String prePoint = new String(chars1);
			n1 = parseIntToDouble(prePoint);
		}
		else
		{//nothing before . so n1=0
			n1=0;
		}

		if (iLook-(pointPos+1) > 0)
		{
			char chars2[] = new char[iLook-(pointPos+1)]; //skip '.' and take rest
			buf.getChars((pointPos+1), iLook, chars2, 0);
			String postPoint = new String(chars2);
			n2 = parseIntToDouble(postPoint);
		}
		else
		{//nothing before . so n2=0
			n2=0;
		}

		number = n1 + n2 / Math.pow(10, iLook-(pointPos+1));
	}
	else
	{// plain integer without '.'
		char chars[] = new char[iLook-startPos];
		buf.getChars(startPos, iLook, chars, 0);
		String temp = new String(chars);
		number = parseIntToDouble(temp);
	}

	//look for e indicating exponential notation
	if ((iLook<buf.length()) && ((buf.charAt(iLook) == 'e') || (buf.charAt(iLook) == 'E')))
	{
		if ((iLook+1 < buf.length()) && ((Character.isDigit(buf.charAt(iLook+1)))
		|| ((iLook+2 < buf.length()) && (buf.charAt(iLook+1) == '-') && (Character.isDigit(buf.charAt(iLook+2))))
		|| ((iLook+2 < buf.length()) && (buf.charAt(iLook+1) == '+') && (Character.isDigit(buf.charAt(iLook+2))))))
		{// e is followed by a integer number, minus, or plus
			boolean negativeSign = false;

			if (buf.charAt(iLook+1) == '-')
			{
				iLook = iLook+2; //skip over negative sign
				negativeSign = true;
			}
			else if (buf.charAt(iLook+1) == '+')
			{
				iLook = iLook+2; //skip over positive sign
				negativeSign = false;
			}
			else
			{
				iLook++; //advance to first number (skip over e)
			}
			startPos = iLook; //set starting point of int

			//go through all
			while ((iLook < buf.length()) && (Character.isDigit(buf.charAt(iLook))))
				iLook++;

			//get the int string and parse it
			char expChars[] = new char[iLook-startPos];
			buf.getChars(startPos, iLook, expChars, 0);
			String expString = new String(expChars);
			double exponent = parseIntToDouble(expString);

			//make the exponent negative
			if (negativeSign)
			{
				exponent = -exponent;
			}

			//multiply the origional number with 10^exponent
			number = number * Math.pow(10, exponent);
		}
		else
		{// e is not followed by a number
	    	throw new ParseException(token, "e not followed by a number");
		}
  	}
    jjtThis.setValue(number);
*/
  }
}